<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>epoll用法 | Wiki</title>
    <meta name="description" content="零散知识整理">
    <link rel="icon" href="/img/light.jpg">
    
    <link rel="preload" href="/assets/css/styles.38c7f6ed.css" as="style"><link rel="preload" href="/assets/js/app.38c7f6ed.js" as="script"><link rel="preload" href="/assets/js/30.7e9dadff.js" as="script"><link rel="prefetch" href="/assets/js/11.36aa27a1.js"><link rel="prefetch" href="/assets/css/1.styles.be7db7cb.css"><link rel="prefetch" href="/assets/js/1.be7db7cb.js"><link rel="prefetch" href="/assets/css/2.styles.0e6b71ee.css"><link rel="prefetch" href="/assets/js/2.0e6b71ee.js"><link rel="prefetch" href="/assets/js/3.a7d30bb9.js"><link rel="prefetch" href="/assets/js/4.1b48aa85.js"><link rel="prefetch" href="/assets/js/5.d0c5a610.js"><link rel="prefetch" href="/assets/js/6.80d57f50.js"><link rel="prefetch" href="/assets/js/7.0a8fe203.js"><link rel="prefetch" href="/assets/js/8.c325de11.js"><link rel="prefetch" href="/assets/js/9.e1fc9576.js"><link rel="prefetch" href="/assets/js/10.22de6067.js"><link rel="prefetch" href="/assets/js/12.363c7724.js"><link rel="prefetch" href="/assets/js/13.bf6652bc.js"><link rel="prefetch" href="/assets/js/14.c9b403ec.js"><link rel="prefetch" href="/assets/js/15.04c8334c.js"><link rel="prefetch" href="/assets/js/16.5e413f13.js"><link rel="prefetch" href="/assets/js/17.41afd675.js"><link rel="prefetch" href="/assets/js/18.bd5e22cc.js"><link rel="prefetch" href="/assets/js/19.d35cb70b.js"><link rel="prefetch" href="/assets/js/20.efcf1f73.js"><link rel="prefetch" href="/assets/js/21.93421747.js"><link rel="prefetch" href="/assets/js/22.eff76cc9.js"><link rel="prefetch" href="/assets/js/23.b7b29c8b.js"><link rel="prefetch" href="/assets/js/24.d54e542b.js"><link rel="prefetch" href="/assets/js/25.d1e16e47.js"><link rel="prefetch" href="/assets/js/26.881f12e6.js"><link rel="prefetch" href="/assets/js/27.43638043.js"><link rel="prefetch" href="/assets/js/28.de1f48b2.js"><link rel="prefetch" href="/assets/js/29.b2afd52f.js"><link rel="prefetch" href="/assets/js/31.2c1ab3e3.js"><link rel="prefetch" href="/assets/js/32.dddab926.js"><link rel="prefetch" href="/assets/js/33.627843a0.js"><link rel="prefetch" href="/assets/js/34.c229b5ef.js"><link rel="prefetch" href="/assets/js/35.2d9bc528.js"><link rel="prefetch" href="/assets/js/36.beb836f2.js"><link rel="prefetch" href="/assets/js/37.7abf04cb.js"><link rel="prefetch" href="/assets/js/38.968d56c9.js"><link rel="prefetch" href="/assets/js/39.6b7d25e9.js"><link rel="prefetch" href="/assets/js/40.8a06f9d8.js"><link rel="prefetch" href="/assets/js/41.668ea981.js"><link rel="prefetch" href="/assets/js/42.3f8fcbdf.js"><link rel="prefetch" href="/assets/js/43.990cef32.js"><link rel="prefetch" href="/assets/js/44.1b21c5c8.js"><link rel="prefetch" href="/assets/js/45.d1eb8981.js"><link rel="prefetch" href="/assets/js/46.48408a4b.js"><link rel="prefetch" href="/assets/js/47.57c4eb0e.js"><link rel="prefetch" href="/assets/js/48.47713b92.js"><link rel="prefetch" href="/assets/js/49.6c822a6a.js"><link rel="prefetch" href="/assets/js/50.9088f270.js">
    <link rel="stylesheet" href="/assets/css/styles.38c7f6ed.css"><link rel="stylesheet" href="/assets/css/1.styles.be7db7cb.css"><link rel="stylesheet" href="/assets/css/2.styles.0e6b71ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Wiki</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/languages/python/" class="nav-link">编程语言</a></div><div class="nav-item"><a href="/systems/linux/" class="nav-link router-link-active">操作系统</a></div><div class="nav-item"><a href="/tools/shell/" class="nav-link">工具</a></div><div class="nav-item"><a href="/others/rubiks/" class="nav-link">其它</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/languages/python/" class="nav-link">编程语言</a></div><div class="nav-item"><a href="/systems/linux/" class="nav-link router-link-active">操作系统</a></div><div class="nav-item"><a href="/tools/shell/" class="nav-link">工具</a></div><div class="nav-item"><a href="/others/rubiks/" class="nav-link">其它</a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Linux</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/systems/linux/" class="sidebar-link">Linux</a></li><li><a href="/systems/linux/epoll-intro.html" class="active sidebar-link">epoll用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/systems/linux/epoll-intro.html#epoll-create" class="sidebar-link">epoll_create</a></li><li class="sidebar-sub-header"><a href="/systems/linux/epoll-intro.html#epoll-ctl" class="sidebar-link">epoll_ctl</a></li><li class="sidebar-sub-header"><a href="/systems/linux/epoll-intro.html#epoll-wait" class="sidebar-link">epoll_wait</a></li><li class="sidebar-sub-header"><a href="/systems/linux/epoll-intro.html#et与lt的区别" class="sidebar-link">ET与LT的区别</a></li><li class="sidebar-sub-header"><a href="/systems/linux/epoll-intro.html#使用注意" class="sidebar-link">使用注意</a></li></ul></li><li><a href="/systems/linux/linux-performance-note.html" class="sidebar-link">Linux程序调试与性能分析</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Mac</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/systems/mac/" class="sidebar-link">Mac</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Windows</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/systems/windows/" class="sidebar-link">Windows</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="epoll用法"><a href="#epoll用法" aria-hidden="true" class="header-anchor">#</a> epoll用法</h1> <p>epoll的接口很简单，只有3个函数</p> <h2 id="epoll-create"><a href="#epoll-create" aria-hidden="true" class="header-anchor">#</a> epoll_create</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>创建一个epoll的句柄，<code>size</code>用来告诉内核这个监听的数目一共有多大。这个参数不同于<code>select()</code>中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用<code>close()</code>关闭，否则可能导致fd被耗尽。</p> <h2 id="epoll-ctl"><a href="#epoll-ctl" aria-hidden="true" class="header-anchor">#</a> epoll_ctl</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>epoll的事件注册函数，它不同与<code>select()</code>是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是<code>epoll_create()</code>的返回值，第二个参数表示动作，用三个宏来表示：</p> <table><thead><tr><th>类型</th> <th>说明</th></tr></thead> <tbody><tr><td><code>EPOLL_CTL_ADD</code></td> <td>注册新的fd到epfd中</td></tr> <tr><td><code>EPOLL_CTL_MOD</code></td> <td>修改已经注册的fd的监听事件</td></tr> <tr><td><code>EPOLL_CTL_DEL</code></td> <td>从epfd中删除一个fd</td></tr></tbody></table> <p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，<code>struct epoll_event</code>结构如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> epoll_event <span class="token punctuation">{</span>
    __uint32_t events<span class="token punctuation">;</span>  <span class="token comment">/* Epoll events */</span>
    epoll_data_t data<span class="token punctuation">;</span>  <span class="token comment">/* User data variable */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>events可以是以下几个宏的集合：</p> <table><thead><tr><th>事件</th> <th>说明</th></tr></thead> <tbody><tr><td><code>EPOLLIN</code></td> <td>表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</td></tr> <tr><td><code>EPOLLOUT</code></td> <td>表示对应的文件描述符可以写；</td></tr> <tr><td><code>EPOLLPRI</code></td> <td>表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</td></tr> <tr><td><code>EPOLLERR</code></td> <td>表示对应的文件描述符发生错误；</td></tr> <tr><td><code>EPOLLHUP</code></td> <td>表示对应的文件描述符被挂断；</td></tr> <tr><td><code>EPOLLET</code></td> <td>将epoll设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</td></tr> <tr><td><code>EPOLLONESHOT</code></td> <td>只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</td></tr></tbody></table> <h2 id="epoll-wait"><a href="#epoll-wait" aria-hidden="true" class="header-anchor">#</a> epoll_wait</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token operator">*</span>epoll_events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>等待事件的产生，类似于<code>select()</code>调用。参数events用来从内核得到事件的集合，<code>maxevents</code>告之内核这个events有多大，这个<code>maxevents</code>的值不能大于创建<code>epoll_create()</code>时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p> <h2 id="et与lt的区别"><a href="#et与lt的区别" aria-hidden="true" class="header-anchor">#</a> ET与LT的区别</h2> <p>从man手册中，得到ET和LT的具体描述如下</p> <p>EPOLL事件有两种模型：</p> <ul><li>Edge Triggered (ET)</li> <li>Level Triggered (LT)</li></ul> <p>假如有这样一个例子：</p> <ol><li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li> <li>这个时候从管道的另一端被写入了2KB的数据</li> <li>调用<code>epoll_wait(2)</code>，并且它会返回RFD，说明它已经准备好读取操作</li> <li>然后我们读取了1KB的数据</li> <li>调用<code>epoll_wait(2)</code>......</li></ol> <h3 id="edge-triggered-工作模式"><a href="#edge-triggered-工作模式" aria-hidden="true" class="header-anchor">#</a> Edge Triggered 工作模式</h3> <p>如果我们在第1步将RFD添加到epoll描述符的时候使用了<code>EPOLLET</code>标志，那么在第5步调用<code>epoll_wait(2)</code>之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。在上面的例子中，会有一个事件产生在RFD句柄上，因为在第2步执行了一个写操作，然后，事件将会在第3步被销毁。因为第4步的读取操作没有读空文件输入缓冲区内的数据，因此我们在第5步调用 <code>epoll_wait(2)</code>完成后，是否挂起是不确定的。</p> <p>epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。</p> <ol><li><p>基于非阻塞文件句柄</p></li> <li><p>只有当<code>read(2)</code>或者<code>write(2)</code>返回<code>EAGAIN</code>时才需要挂起，等待。但这并不是说每次<code>read()</code>时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当<code>read()</code>返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p></li></ol> <h3 id="level-triggered-工作模式"><a href="#level-triggered-工作模式" aria-hidden="true" class="header-anchor">#</a> Level Triggered 工作模式</h3> <p>相反的，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的<code>poll(2)</code>，并且无论后面的数据是否被使用，因此他们具有同样的职能。因为即使使用ET模式的epoll，在收到多个chunk的数据的时候仍然会产生多个事件。调用者可以设定<code>EPOLLONESHOT</code>标志，在 <code>epoll_wait(2)</code>收到事件后epoll会与事件关联的文件句柄从epoll描述符中禁止掉。因此当<code>EPOLLONESHOT</code>设定后，使用带有 <code>EPOLL_CTL_MOD</code>标志的<code>epoll_ctl(2)</code>处理文件句柄就成为调用者必须作的事情。</p> <h3 id="et-lt对比"><a href="#et-lt对比" aria-hidden="true" class="header-anchor">#</a> ET/LT对比</h3> <p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表．</p> <p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认（这句话不理解）。</p> <p>在许多测试中我们会看到如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当我们遇到大量的idle- connection(例如WAN环境中存在大量的慢速连接)，就会发现epoll的效率大大高于select/poll。（未测试）</p> <p>另外，当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，
读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    buflen <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>activeevents<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>buflen <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span>
        <span class="token comment">// 在这里就当作是该次事件已处理处.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buflen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 这里表示对端的socket已正常关闭.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>buflen <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span>
        rs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 需要再次读取</span>
    <span class="token keyword">else</span>
        rs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有，假如发送端流量大于接收端的流量(意思是epoll所在的程序读比转发的socket要快),由于是非阻塞的socket,那么send()函数虽然返回,但实际缓冲区的数据并未真正发给接收端,这样不断的读和发，当缓冲区满后会产生EAGAIN错误(参考man send),同时,不理会这次请求发送的数据.所以,需要封装socket_send()的函数用来处理这种情况,该函数会尽量将数据写完再返回，返回-1表示出错。在socket_send()内部,当写缓冲已满(send()返回-1,且errno为EAGAIN),那么会等待后再重试.这种方式并不很完美,在理论上可能会长时间的阻塞在socket_send()内部,但暂没有更好的办法.</p> <div class="language-c extra-class"><pre class="language-c"><code>ssize_t <span class="token function">socket_send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> size_t buflen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ssize_t tmp<span class="token punctuation">;</span>
    size_t total <span class="token operator">=</span> buflen<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> buffer<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        tmp <span class="token operator">=</span> <span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> p<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 当send收到信号时,可以继续写,但这里返回-1.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

            <span class="token comment">// 当socket是非阻塞时,如返回此错误,表示写缓冲队列已满,</span>
            <span class="token comment">// 在这里做延时后再重试.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>tmp <span class="token operator">==</span> total<span class="token punctuation">)</span>
            <span class="token keyword">return</span> buflen<span class="token punctuation">;</span>

        total <span class="token operator">-</span><span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        p <span class="token operator">+</span><span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="使用注意"><a href="#使用注意" aria-hidden="true" class="header-anchor">#</a> 使用注意</h2> <ul><li><p>阻塞的socket在<code>epoll_wait</code>后调用<code>accept</code>，在<code>epoll_wait</code>返回到accept调用这段时间，服务器收到rst报文，会导致调用accept阻塞，直到下一个连接的到来。</p></li> <li><p>stale event</p></li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/systems/linux/" class="prev router-link-active">
          Linux
        </a></span> <span class="next"><a href="/systems/linux/linux-performance-note.html">
          Linux程序调试与性能分析
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/30.7e9dadff.js" defer></script><script src="/assets/js/app.38c7f6ed.js" defer></script>
  </body>
</html>
